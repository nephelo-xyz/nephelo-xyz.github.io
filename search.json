[{"title":"SpringBoot自动装配机制","url":"/2019/12/14/SpringBoot自动装配机制/","content":"\nSpringBoot为什么会出现？说白了还是觉得Spring不够方便不够简化。SpringBoot一个脚手架让你一分钟就生成一个web项目\n\n为什么会这么快？为什么连基础配置都不需要？\n\n<!--more-->\n\n## SpringBoot自动装配如何实现的？\n\n### - SpringBoot\n\n> SpringBoot中的 @Configuration和@Bean 大家都很熟悉，标注此类是一个注解类，提示Spring扫描的作用。\n>\n> 那么如果我有这样一个诉求：\n>\n> 1. 我有100个@Configuration类\n> 2. 我某个模块需要让其中50个类 注入Spring中，该怎么操作？\n\n### - SpringBoot自动注入\n\n1. 从`@SpringBootApplication`入手，可以看见此注解是一个复合注解。其中`@SpringBootConfiguration`是继承`@Configuration`，所以这个注解我们可以知道他的大概作用，还有另一个注解\n\n   ```java\n   @Target(ElementType.TYPE)\n   @Retention(RetentionPolicy.RUNTIME)\n   @Documented\n   @Inherited\n   @SpringBootConfiguration\n   @EnableAutoConfiguration\n   @ComponentScan(excludeFilters = {\n   \t\t@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n   \t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\n   public @interface SpringBootApplication {}\n   ```\n\n   `@EnableAutoConfiguration`中有`@AutoConfigurationPackage`和`@Import`注解，`@AutoConfigurationPackage`注解是自动获取注册Package列表，下来我们看`@import(AutoConfigurationImportSelector.class)`的注解\n\n   ```java\n   @Target(ElementType.TYPE)\n   @Retention(RetentionPolicy.RUNTIME)\n   @Documented\n   @Inherited\n   @AutoConfigurationPackage\n   @Import(AutoConfigurationImportSelector.class)\n   public @interface EnableAutoConfiguration {\n   ```\n\n   > `@Import` 注解可以配置三种不同的 class\n   >\n   > 1. 基于普通 bean 或者带有`@Configuration` 的 `@bean` 进行注入\n   > 2. 实现 `ImportSelector` 接口进行动态注入\n   >\n   > ```java\n   > //通过实现selectImports方法，返回需要注入的ClassName即可实现动态注入。\n   > String[] selectImports(AnnotationMetadata importingClassMetadata);\n   > ```\n   >\n   > 3. 实现 `ImportBeanDefinitionRegistrar` 接口进行动态注入  \n   >\n   > ```java\n   > //通过实现registerBeanDefinitions方法，将需要返回的ClassName[]塞给registry即可实现动态注入\n   > void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);\n   > ```\n   >\n\n   `AutoConfigurationImportSelector`这个类实现了`ImportSelector`类。\n\n2. 所以说实现`ImportSelector`就可以进行注入Spring，返回的`String[]`就是需要注入Spring的Bean的ClassName，那么我们可以想想，返回一个`String[]`数组的ClassNme，我们可不可以定义到一个配置文件中呢？配置文件我们可以这样配置 `key:ClassName[]`，key就是要满足的条件（一个注解类，只要注解了key注解类），即获取其中的`ClassName[]`，然后返回给Spring动态注入。这样不就方便管理了吗？\n\n   > SpringBoot就是这么操作的，SpringBoot定义了`spring.factories`文件，默认放在项目的`\\resources\\META-INF\\spring.factories`，SpringBoot加载所有项目下的spring.factories，将同一key的value[]整合，然后去重，然后去除`@exclude`注解过滤的类，剩余类全部注入。\n   >\n   > ==我们怎么使用？==\n   >\n   > 我们可以在自己的项目`\\resources\\META-INF\\`目录下建立`spring.factories`文件，按照SpringBoot中的格式。加入自己定义的`@Configuration`类即可实现Spring自动装配。\n   >\n   > ```properties\n   > org.springframework.boot.autoconfigure.EnableAutoConfiguration= \\\n   >   com.nephelo.commons.tool.redisconfig.RedissonAutoConfiguration,\\\n   >   com.nephelo.commons.tool.zookeeperConfig.ZookeeperAutoConfiguration\n   > ```\n   >\n   > 如果是自己定义的注解类(一般不建议)，我们需要实现`ImportBeanDefinitionRegistrar`或者`ImportSelector`在此注解上加上`@Import(AutoConfigurationImportSelector.class)`或者` import(ImportSelector.class)`即可。\n\n3. 自动装配的条件注解`@Conditional xxx`\n\n   > ```java\n   > @ConditionalOnClass  //当有某个class的时候加载\n   > @ConditionalOnBean   //当有某个bean的时候加载\n   > @ConditionalOnMissingClass  //当不存在某个class的时候加载\n   > @ConditionalOnMissingBean   //当不存在某个bean的时候加载\n   > ...\n   > ```\n\n+ 为什么？我们依赖一个`starter`就可以自动装配\n\n  > 就是因为Starter的jar包中，就会配置上面的自动装配装配，实现自动注入\n\n\n\n","tags":["SpringBoot"]},{"title":"MySQL的事务和ACID实现原理","url":"/2019/12/13/MySQL实现ACID原理/","content":"\n### ACID\n\nACID我们大家都知道，面试官也经常问到：\n\n不就是 原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability) 嘛！\n\n<!-- more -->\n\n#### 三大读取问题\n\n1. **脏读(P1)** ： 读取到别的事务修改的数据，但是别的事务未结束，也就是没有commit或者回滚。\n2. **不可重复读(P2)**：读取到别的事务修改的数据（或者删除的数据），但是别的事务已经commit。\n3. **幻读(P3)**：读取到别的事务增加的数据，并且已经提交。\n\n+ 其实都是读一致性问题\n\n#### 数据一致性标准（SQL92 ANSI/ISO）\n\n在http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt SQL92标准中，是如下定义的：\n\n1. **未提交读**(Read Uncommitted)：事务未提交的数据其他事务可见，解决P1\n2. **已提交读**(Read Committed)：事务只能读取别的事务提交后的数据，解决P2\n3. **可重复度**(Repeatable Read)：同一个事务中可以多次读取同样的数据 是一样的。\n   + SQL92官方未提出可以解决P3，但是在innodb中，不可能出现P3（==MySQL官网==）\n4. **串行化**(Serializable)：串行方式执行事务。解决P1P2P3\n\n### 两大实现方案\n\n如果要解决读一致问题，保证一个事务前后两次读取数据一致，该怎么做？在MySQL中用以下两种方案实现\n\n#### 1. LBCC\n\n**Lock Based Concurrency Control**：这种方案是基于锁的并发控制\n\n##### 1.1 锁的种类\n\n**行锁：**行级别的锁\n\n**表锁：**锁住一张表\n\n**共享锁：**也叫**读锁**，我们获取了 一行数据的读锁以后，可以用来读取数据，所以它也叫做读锁\n\n> ```sql\n> -- 我们可用以下方式加上读锁 \n> select ... lock in share mode;\n> ```\n>\n> 注意在加上了读锁以后是可以去写数据的，但是很可能会造成死锁。\n>\n> 释放锁有两种方式，只要事务结束，锁就会自动事务，包括提交事务和结束事务。\n\n**排它锁：**也叫**写锁**，只要一个事务获取了一行数据的排它锁，其他的事务就不能再获取这一行数据的共享锁和排它锁。 \n\n> ```sql\n> -- 我们可以加上FOR UPDATE的方式，给select加上排它锁\n> SELECT .... FOR UPDATE\n> ```\n\n**意向锁：**这个锁我们好像很陌生，也从来没用过？那这个锁是干什么的呢？其实它是由数据库自己维护，也就是说，当我们在给一行数据加上共享锁时，数据会自动给这张表加上意向共享锁；当我们在给一行数据加上排它锁时，数据会自动给这张表加上意向排它锁。\n\n反过来说： 如果一张表上面至少有一个意向共享锁，说明有其他的事务给其中的某些数据行加 上了共享锁。 如果一张表上面至少有一个意向排他锁，说明有其他的事务给其中的某些数据行加 上了排他锁。\n\n那这个锁有什么意义呢？\n\n> 1. 在我们给在某个表加上表锁时，他会怎么操作呢？他会首先扫描表中所有的行，如果某个行被加了行锁，那么就不允许在加表锁了，在大数据量时效率肯定会很低。如果有意向锁就不一样了，他就可以直接判断这个表是否有意向锁的存在，如果有那就说明有人使用行锁中。\n> 2. 这样以来，InnoDB就实现了表锁和行锁两个级别。虽然表锁只是一种标志的感觉。*注：MyISAM只支持表锁* \n\n##### 1.2 锁的原理\n\n一个锁他到底锁住了什么？我们知道Java锁会在对象头中标识，那么MySQL是不是也在头中呢？\n\n> 验证：\n>\n> 1. 我们先来看一下 t1 的表结构，它有两个字段，int 类型的 id 和 varchar 类型的 name。 里面有 4 条数据，1、2、3、4。\n>\n> | transaction1                             | transaction2                                            |\n> | ---------------------------------------- | ------------------------------------------------------- |\n> | begin;                                   |                                                         |\n> | SELECT * FROM t1 WHERE id =1 FOR UPDATE; |                                                         |\n> |                                          | select * from t1 where id=3 for update; --阻塞          |\n> |                                          | INSERT INTO `t1` (`id`, `name`) VALUES (5, '5'); --阻塞 |\n>\n> 为什么加了 id = 1的行锁， id=3和id=5的查询和插入都被阻塞了呢？难道是加了表锁？\n>\n> 2. 我们看一下 t2 的表结构。字段是一样的，不同的地方是 id 上创建了一个`主键索引`。 里面的数据是 1、4、7、10\n>\n> | transaction1                            | transaction2                                   |\n> | --------------------------------------- | ---------------------------------------------- |\n> | begin;                                  |                                                |\n> | select * from t2 where id=1 for update; |                                                |\n> |                                         | select * from t2 where id=1 for update; //阻塞 |\n> |                                         | select * from t2 where id=4 for update; // OK  |\n>\n> 可以看出使用不同`主键ID`是可以查询的\n\n> <font color='red'>结论：</font>\n>\n> 1）如果我们定义了主键(PRIMARY KEY)，那么 InnoDB 会选择主键作为聚集索引。 \n>\n> 2）如果没有显式定义主键，则 InnoDB 会选择第一个不包含有 NULL 值的唯一索 引作为主键索引。 \n>\n> 3）如果也没有这样的唯一索引，则 InnoDB 会选择内置 6 字节长的 ROWID 作为隐藏的聚集索引，它会随着行记录的写入而主键递增。\n>\n> 所以，为什么锁表，是因为查询没有使用索引，会进行全表扫描，然后把每一个隐 藏的聚集索引都锁住了。\n\n> 问题1：\n>\n> 为什么通过唯一索引加上行锁，主键索引也会被锁住？\n>\n> 在InnoDB中主键索引是聚集索引，唯一索引就是辅助索引。我们知道辅助索引的检索流程，在辅助索引的叶子节点存的是聚集索引的索引ID，所以还会再次检索聚集索引的树才能找到文件。所以当找到聚集索引之后肯定会锁起来。\n\n##### 1.3 锁的算法\n\n**记录锁**：\n\n当我们对于唯一性的索引（包括唯一索引和主键索引）使用等值查询，精准匹配到一条记录的时候，这个时候使用的就是记录锁。会只锁住当前的记录(record)\n\n**间隙锁：**\n\n当我们查询的记录不存在，没有命中任何一个 record，无论是用等值查询还是范围查询的时候，它使用的都是间隙锁。\n\n> 举个例子：我们的表中主键现在有 1 ，4，7，10，当我们执行`where id = 6`的时候，查询记录不存在，就会使用间隙锁。除了主键，外键和唯一性检查会加间隙锁。\n>\n> 关闭间隙锁：首先把事务级别设置为RC，并把 innodb_locks_unsafe_for_binlog 设置为 ON。\n\n**临键锁：**\n\n>  不仅仅命中了 Record 记录，还包含了 Gap间隙，在这种情况下我们使用的就是临键锁，它是 MySQL 里面默认的行锁算法，相当于记录锁加上间隙锁。唯一性索引，等值查询匹配到一条记录的时候，退化成记录锁\n\n> 举个例子：我们的表中主键现在有 1 ，4，7，10，当我们执行`where id > 5 and id < 9`的时候，查询记录就存在一个record 7\n>\n> ```sql\n> select * from t2 where id >5 and id <=7 for update; -- 锁住(4,7]和(7,10]\n> select * from t2 where id >8 and id <=10 for update; -- 锁住 (7,10]，(10,+∞)\n> ```\n>\n> 为什么要锁住下一个左开右闭的区间？——就是为了解决幻读的问题。 \n\n#### 2.MVCC\n\n**Multi Version Concurrency Control**：使用多版本的并发控制\n\n​\t**mvcc的实现原理**：\n\n+ 一个事务在一时间点读取，会把当前数据生成快照。\n\n+ innodb中快照会有两个标识，一个是（DB_TRX_ID）事务ID（==也可以理解为快照版本==），一个是（DB_ROLL_PTR）回滚指针。\n\n+ 事务1读取数据\n\n  > 读取数据，只会读取**DB_TRX_ID小于等于当前事务ID的数据和DB_ROLL_PTR大于当前事务ID**的数据。\n  >\n  > ```sql\n  > select * from user;\n  > ```\n\n  | ID   | name | DB_TRX_ID | DB_ROLL_PTR |\n  | ---- | ---- | --------- | ----------- |\n  | 1    | jack | 1         | undefined   |\n  | 2    | tom  | 1         | undefined   |\n\n  *-- 此时为初始状态*\n\n+ 事务2删除数据，会更新DB_ROLL_PTR的值为事务DB_TRX_ID+1\n\n  ```sql\n  //现在事务ID为2的事务 删除jack这个数据\n  delete user where id =1\n  ```\n\n  | ID   | name | DB_TRX_ID | DB_ROLL_PTR                |\n  | ---- | ---- | --------- | -------------------------- |\n  | 1    | jack | 1         | <font color='red'>2</font> |\n  | 2    | tom  | 1         | undefined                  |\n\n  *所以不影响 事务1 读取的数据*\n\n+ 事务3插入一条数据，此时快照中的变化。\n\n  > 插入数据会创建DB_TRX_ID为当前事务ID、DB_ROLL_PTR为undefined的数据。\n\n  ```sql\n  begin;\n  insert into user values (3,'jerry');\n  commit;\n  ```\n\n  | ID   | name  | DB_TRX_ID                   | DB_ROLL_PTR |\n  | ---- | ----- | --------------------------- | ----------- |\n  | 1    | jack  | 1                           | 2           |\n  | 2    | tom   | 1                           | undefined   |\n  | 3    | jerry | <font color='red'> 3</font> | undefined   |\n\n+ 事务1第二次查询\n\n  ```sql\n  select * from user;\n  ```\n\n  | ID   | name | DB_TRX_ID | DB_ROLL_PTR |\n  | ---- | ---- | --------- | ----------- |\n  | 1    | jack | 1         | 2           |\n  | 2    | tom  | 1         | undefined   |\n\n  **DB_TRX_ID小于等于当前事务ID的数据和DB_ROLL_PTR大于当前事务ID**\n\n+ 事务4更新一数据\n\n  > 更新数据会使快照创建出一条ID相同的更新后的数据，事务ID为删除事务的事务ID，DB_ROLL_PTR为null。并且更新源数据行的DB_ROLL_PTR为，更新操作事务ID+1\n\n  ```sql\n  //现在事务ID为3的事务更新了 jack这个数据\n  begin;\n  update user set name = 'pengyuyan' where id =1;\n  commit;\n  ```\n\n  | ID   | name      | DB_TRX_ID                  | DB_ROLL_PTR                |\n  | ---- | --------- | -------------------------- | -------------------------- |\n  | 1    | jack      | 1                          | <font color='red'>4</font> |\n  | 2    | tom       | 1                          | undefined                  |\n  | 3    | jerry     | 3                          | undefined                  |\n  | 1    | pengyuyan | <font color='red'>4</font> | undefined                  |\n\n  *也不影响 事务1读取的数据，现在的第一条数据叫做 undolog*\n\n#### 默认开启增删改事务\n\n```mysql\nshow global VARIABLES like 'autocommit'; //默认为ON的时候 增删改都会自动开启和关闭事务\n```\n\n### 总结\n\n#### 原子性的实现：\n\n通过`undo log`实现，`undo log`也就是数据修改之前的值，一但发生异常就可以通过`undo log`恢复。\n\n#### 一致性的实现：\n\n事务执行的 前后都是合法的数据状态。比如主键必须是唯一的，字段长度符合要求。但是除了数据提供的基础一致性，我们在操作时也要判断数据的合法性，比如：表中金额为20，操作时再减去100变成-80，这就不合法。\n\n#### 隔离性的实现：\n\n通过`mvcc`（基于快照）和`LBCC`（基于锁，表锁行锁）实现\n\n#### 持久性的实现：\n\n通过`redo log`（灾难恢复）和`double write`（页数据双写）双写缓冲来实现，`redo log `默认存放在`/var/lib/mysql/`目录中，默认一个48M\n\n```sql\nshow variables like 'innodb_log%'; 查看\ninnodb_log_file_size  # 指定每个文件的大小，默认 48M\ninnodb_log_files_in_group # 指定文件的数量，默认为 2\ninnodb_log_group_home_dir # 指定文件所在路径，相对或绝对。如果不指定，则为 datadir 路径。\n```\n\n","tags":["MySQL"]},{"title":"Start","url":"/2019/01/01/Start/","content":"\n **不管怎么说，希望是一个美好的开始！！**\n\n<!-- more -->\n\n"}]